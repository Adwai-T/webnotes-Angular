/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./Maps/Map_1.js":
/*!***********************!*\
  !*** ./Maps/Map_1.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"STAGE\": () => (/* binding */ STAGE)\n/* harmony export */ });\nconst STAGE = {\r\n    MAXCOL : 32,\r\n    TILES : [12, 32, 32, 32, 12, 32, 32, 32, 12, 32, 32, 32, 32, 32, 32, 12, 32, 32, 32, 32, 32, 12, 32, 32, 32, 32, 12, 32, 32, 32, 32, 12, 32, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 326, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 32, 12, 131, 132, 132, 132, 346, 347, 132, 132, 347, 132, 132, 132, 132, 132, 326, 132, 132, 132, 132, 132, 347, 132, 347, 132, 132, 347, 132, 132, 132, 1, 32, 32, 131, 132, 132, 132, 132, 132, 132, 347, 132, 132, 132, 132, 132, 132, 326, 132, 132, 132, 347, 132, 132, 132, 132, 132, 347, 132, 132, 132, 132, 1, 32, 32, 131, 132, 132, 132, 132, 132, 347, 132, 132, 327, 132, 132, 132, 132, 326, 132, 132, 132, 132, 132, 347, 132, 132, 132, 132, 132, 132, 276, 277, 278, 12, 32, 131, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 346, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 249, 298, 32, 32, 131, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 324, 132, 132, 132, 132, 132, 132, 132, 20, 298, 32, 12, 131, 132, 132, 132, 132, 132, 132, 132, 132, 187, 132, 132, 132, 132, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 132, 97, 40, 298, 32, 32, 131, 132, 132, 132, 132, 132, 132, 132, 132, 207, 132, 132, 132, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 132, 18, 18, 298, 32, 32, 131, 132, 132, 132, 132, 132, 132, 132, 132, 207, 132, 132, 10, 10, 10, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 72, 72, 316, 317, 318, 12, 32, 131, 132, 132, 132, 132, 132, 132, 132, 132, 10, 10, 10, 10, 10, 10, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 1, 32, 32, 131, 132, 1, 132, 132, 132, 132, 132, 132, 132, 132, 350, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 1, 32, 32, 131, 132, 55, 132, 132, 132, 132, 132, 132, 132, 132, 350, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 1, 32, 12, 131, 132, 56, 132, 132, 164, 164, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 10, 10, 10, 388, 389, 95, 388, 389, 95, 388, 389, 132, 1, 32, 32, 131, 132, 70, 70, 70, 28, 28, 132, 132, 187, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 1, 32, 32, 131, 132, 132, 132, 167, 167, 167, 132, 132, 207, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 1, 12, 32, 131, 132, 132, 132, 132, 132, 132, 132, 132, 132, 125, 126, 126, 126, 126, 126, 126, 127, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 1, 32, 32, 131, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 1, 32, 12, 131, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 1, 32, 32, 131, 132, 132, 132, 132, 132, 132, 10, 10, 10, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 1, 32, 32, 131, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 16, 132, 132, 132, 132, 132, 132, 132, 132, 164, 132, 132, 14, 18, 38, 132, 132, 1, 12, 32, 131, 132, 10, 10, 10, 132, 132, 132, 132, 132, 132, 132, 15, 132, 132, 132, 132, 132, 132, 10, 10, 10, 132, 132, 72, 72, 72, 132, 132, 1, 32, 32, 39, 39, 39, 39, 39, 39, 39, 39, 132, 55, 55, 55, 39, 39, 39, 39, 39, 55, 132, 132, 132, 132, 132, 132, 72, 72, 72, 72, 72, 1, 32, 32, 32, 32, 32, 12, 32, 32, 32, 32, 12, 32, 32, 32, 32, 32, 12, 32, 32, 32, 32, 32, 12, 32, 32, 32, 32, 32, 32, 12, 32, 32, 32],\r\n    COLLISIONTILENUMBER : 373,\r\n    COLLISIONARRAY : [373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 373, 373, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 0, 0, 373, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 0, 0, 373, 373, 373, 0, 0, 0, 373, 373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 373, 373, 373, 373, 373, 0, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373],\r\n}\n\n//# sourceURL=webpack://webengine/./Maps/Map_1.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Maps_Map_1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Maps/Map_1.js */ \"./Maps/Map_1.js\");\n/* harmony import */ var _src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/Canvas.js */ \"./src/Canvas.js\");\n/* harmony import */ var _src_collision_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/collision.js */ \"./src/collision.js\");\n/* harmony import */ var _src_input_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/input.js */ \"./src/input.js\");\n\r\n\r\n\r\n\r\n\r\nconst CANVAS_WIDTH = 800;\r\nconst CANVAS_HEIGHT = 600;\r\n\r\nlet mapCanvas = new _src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.Canvas(CANVAS_WIDTH, CANVAS_HEIGHT, \"Canvas\", \"mapCanvas\");\r\nmapCanvas.canvas.style = \"background-color: lightgrey;\";\r\nlet collisionCanvas = new _src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.Canvas(\r\n  CANVAS_WIDTH,\r\n  CANVAS_HEIGHT,\r\n  \"Canvas\",\r\n  \"collisionCanvas\"\r\n);\r\n\r\n(0,_src_input_js__WEBPACK_IMPORTED_MODULE_3__.add_events)(collisionCanvas.canvas);\r\n\r\n//Load Images\r\nlet tileMapImage = (0,_src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.loadImage)(\"./res/monochrome.png\");\r\nlet tileMapImageTileSize = 16;\r\nlet tileMapImageOriginCoordinate = _src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.Tiles.generateTileArray(\r\n  20,\r\n  20,\r\n  tileMapImageTileSize\r\n);\r\n\r\nlet animSheet = (0,_src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.loadImage)(\"./res/animSheet.png\");\r\nlet animSheetTileSize = 16;\r\nlet animSheetImageOriginCoordinates = _src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.Tiles.generateTileArray(\r\n  8,\r\n  6,\r\n  animSheetTileSize\r\n);\r\n\r\nconst MAPTILESIZE = 25;\r\n\r\n//player\r\nlet player = {\r\n  rect: new _src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.Rectangle(new _src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.Vector2i(549, 51), new _src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.Vector2i(24, 24)),\r\n  spriteAnimation: {\r\n    idle: [1],\r\n    right: [2, 3, 4, 5],\r\n    left: [20, 21, 22, 23],\r\n    jumpRight: [14, 15, 16, 17],\r\n    jumpLeft: [26, 27, 28, 29],\r\n    duck: [6],\r\n  },\r\n  movementSpeed: {\r\n    x: 2,\r\n    y: 2,\r\n  },\r\n  mass: 60,\r\n  force: 0,\r\n  acceleration: 0,\r\n  velocity: 0,\r\n};\r\n\r\nplayer.animState = {\r\n  currentState: player.spriteAnimation.idle,\r\n  currentAnimIndex: 0,\r\n  cycleAnim: function (animatePerFrames, currentFrameNumber) {\r\n    if (currentFrameNumber % animatePerFrames === 0) {\r\n      if (this.currentAnimIndex < this.currentState.length - 1) {\r\n        this.currentAnimIndex++;\r\n      } else {\r\n        this.currentAnimIndex = 0;\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n(0,_src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.setMovable)(player.rect);\r\n\r\n//Draw Map\r\nlet tileMapCoordinates = _src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.Tiles.generateTileArray(\r\n  CANVAS_HEIGHT / MAPTILESIZE,\r\n  CANVAS_WIDTH / MAPTILESIZE,\r\n  MAPTILESIZE\r\n);\r\nconst drawMap = function () {\r\n  _Maps_Map_1_js__WEBPACK_IMPORTED_MODULE_0__.STAGE.TILES.forEach((value, i) => {\r\n    new _src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.Rectangle(\r\n      tileMapCoordinates[i],\r\n      new _src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.Vector2i(MAPTILESIZE, MAPTILESIZE)\r\n    ).drawSprite(\r\n      mapCanvas.ctx,\r\n      tileMapImage,\r\n      tileMapImageOriginCoordinate[value - 1],\r\n      tileMapImageTileSize,\r\n      tileMapImageTileSize\r\n    );\r\n  });\r\n};\r\n\r\ntileMapImage.onload = (e) => {\r\n  drawMap();\r\n};\r\n\r\n//Generate Static Collision Rectangles\r\nconst staticCollisionRectangleArray = (0,_src_collision_js__WEBPACK_IMPORTED_MODULE_2__.parseCollisionRectangles)(\r\n  _Maps_Map_1_js__WEBPACK_IMPORTED_MODULE_0__.STAGE.COLLISIONARRAY,\r\n  MAPTILESIZE,\r\n  CANVAS_WIDTH / MAPTILESIZE,\r\n  CANVAS_HEIGHT / MAPTILESIZE,\r\n  _Maps_Map_1_js__WEBPACK_IMPORTED_MODULE_0__.STAGE.COLLISIONTILENUMBER\r\n);\r\n\r\n//Update Dynamic collision rectangles\r\n\r\n//Update Player Positions\r\nlet updateInput = function (player) {\r\n  (0,_src_Canvas_js__WEBPACK_IMPORTED_MODULE_1__.updateLastPostion)(player.rect);\r\n  \r\n  player.animState.currentState = player.spriteAnimation.idle;\r\n\r\n  if (_src_input_js__WEBPACK_IMPORTED_MODULE_3__.KeyPressed.D) {\r\n    player.animState.currentState = player.spriteAnimation.right;\r\n    player.rect.vec.x += player.movementSpeed.x;\r\n  }\r\n  if (_src_input_js__WEBPACK_IMPORTED_MODULE_3__.KeyPressed.A) {\r\n    player.animState.currentState = player.spriteAnimation.left;\r\n    player.rect.vec.x -= player.movementSpeed.x;\r\n  }\r\n  if (_src_input_js__WEBPACK_IMPORTED_MODULE_3__.KeyPressed.W) {\r\n    player.rect.vec.y -= player.movementSpeed.y;\r\n  }\r\n  if (_src_input_js__WEBPACK_IMPORTED_MODULE_3__.KeyPressed.S) {\r\n    player.animState.currentState = player.spriteAnimation.duck;\r\n    player.rect.vec.y += player.movementSpeed.y;\r\n  }\r\n  if(_src_input_js__WEBPACK_IMPORTED_MODULE_3__.KeyPressed.D && _src_input_js__WEBPACK_IMPORTED_MODULE_3__.KeyPressed.W){\r\n    player.animState.currentState = player.spriteAnimation.jumpRight;\r\n  }\r\n  if(_src_input_js__WEBPACK_IMPORTED_MODULE_3__.KeyPressed.A && _src_input_js__WEBPACK_IMPORTED_MODULE_3__.KeyPressed.W){\r\n    player.animState.currentState = player.spriteAnimation.jumpLeft;\r\n  }\r\n\r\n};\r\n\r\n//Draw Updated Objects\r\nfunction draw() {\r\n\r\n  //Sometimes player.animState.currentState becomes \"undefined\" and so we have a check\r\n  if(player.animState.currentState[player.animState.currentAnimIndex]){    \r\n    player.rect.drawSprite(\r\n      collisionCanvas.ctx,\r\n      animSheet,\r\n      animSheetImageOriginCoordinates[player.animState.currentState[player.animState.currentAnimIndex]],\r\n      animSheetTileSize,\r\n      animSheetTileSize\r\n    );\r\n  }\r\n}\r\n\r\n//Update Collision\r\nlet updateCollision = function () {\r\n  staticCollisionRectangleArray.forEach((rect) => {\r\n    (0,_src_collision_js__WEBPACK_IMPORTED_MODULE_2__.checkAndResolveCollision)(\r\n      player.rect,\r\n      rect,\r\n      player.isMovable,\r\n      rect.isMovable\r\n    );\r\n  });\r\n};\r\n\r\n//GameLoop Start\r\nlet frameCounter = 0;\r\nlet totalTime = 0; //Time Reset every second\r\nlet lastTime = 0; //Time at which the last frame was rendered\r\nlet currentFrameRate = 0;\r\n\r\nfunction drawAtXFps(FPS) {\r\n  //FPS calculations\r\n  let timestart = Date.now();\r\n  let fps = timestart - lastTime;\r\n  totalTime += fps;\r\n  frameCounter++;\r\n  if (totalTime >= 1000) {\r\n    currentFrameRate = frameCounter;\r\n    frameCounter = 0;\r\n    totalTime = 0;\r\n  }\r\n\r\n  lastTime = timestart;\r\n\r\n  //Clear Screen Each Frame\r\n  collisionCanvas.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n\r\n  //Update and Draw\r\n  updateInput(player);\r\n  updateCollision();\r\n  player.animState.cycleAnim(4, frameCounter);\r\n  draw();\r\n\r\n  //Draw Fps\r\n  collisionCanvas.ctx.fillStyle = \"White\";\r\n  collisionCanvas.ctx.font = \"15px Arial\";\r\n  collisionCanvas.ctx.fillText(currentFrameRate, CANVAS_WIDTH - 50, 50);\r\n\r\n  window.requestAnimationFrame(drawAtXFps);\r\n}\r\n\r\nwindow.requestAnimationFrame(drawAtXFps);\r\n\n\n//# sourceURL=webpack://webengine/./index.js?");

/***/ }),

/***/ "./src/Canvas.js":
/*!***********************!*\
  !*** ./src/Canvas.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Canvas\": () => (/* binding */ Canvas),\n/* harmony export */   \"getRandomColor\": () => (/* binding */ getRandomColor),\n/* harmony export */   \"loadImage\": () => (/* binding */ loadImage),\n/* harmony export */   \"drawSprite\": () => (/* binding */ drawSprite),\n/* harmony export */   \"Vector2i\": () => (/* binding */ Vector2i),\n/* harmony export */   \"setMovable\": () => (/* binding */ setMovable),\n/* harmony export */   \"updateLastPostion\": () => (/* binding */ updateLastPostion),\n/* harmony export */   \"Point\": () => (/* binding */ Point),\n/* harmony export */   \"Line\": () => (/* binding */ Line),\n/* harmony export */   \"Rectangle\": () => (/* binding */ Rectangle),\n/* harmony export */   \"Tiles\": () => (/* binding */ Tiles)\n/* harmony export */ });\nclass Canvas {\r\n  constructor(width, height, elementId, id) {\r\n    Canvas.numberOfCanvas++;\r\n    this.width = width;\r\n    this.height = height;\r\n\r\n    //Create canvas element\r\n    this.canvas = document.createElement(\"canvas\");\r\n    this.canvas.width = width;\r\n    this.canvas.height = height;\r\n    this.canvas.tabIndex = 1;\r\n    this.canvas.style = \"border:1px solid #000000; cursor: none\";\r\n    document.getElementById(elementId).appendChild(this.canvas);\r\n\r\n    if (typeof id === \"string\") {\r\n      this.canvas.id = id;\r\n      this.id = id;\r\n    }\r\n\r\n    this.ctx = this.canvas.getContext(\"2d\");\r\n  }\r\n\r\n  setID(id) {\r\n    this.id = id;\r\n  }\r\n\r\n  clearCanvas() {\r\n    this.ctx.clearRect(0, 0, this.width, this.height);\r\n  }\r\n}\r\n\r\n/**\r\n * Get a Random Color in Hex\r\n */\r\nfunction getRandomColor() {\r\n  var letters = \"0123456789ABCDEF\";\r\n  var color = \"#\";\r\n  for (var i = 0; i < 6; i++) {\r\n    color += letters[Math.floor(Math.random() * 16)];\r\n  }\r\n  return color;\r\n}\r\n\r\n/**\r\n * Load and return Image\r\n * @param {string} src\r\n */\r\nfunction loadImage(src) {\r\n  let image = new Image();\r\n  image.src = src;\r\n  return image;\r\n}\r\n\r\nfunction drawSprite(context, image, rect_ImageSource, rect_drawImage) {\r\n  if (image) {\r\n    context.drawImage(\r\n      image,\r\n      rect_ImageSource.vec.x,\r\n      rect_ImageSource.vec.y,\r\n      rect_ImageSource.width,\r\n      rect_ImageSource.height, //src coords\r\n      rect_drawImage.vec.x,\r\n      rect_drawImage.vec.y,\r\n      rect_drawImage.width,\r\n      rect_drawImage.height //dst coords\r\n    );\r\n  }\r\n}\r\n\r\n//--- Vector\r\n\r\n/**\r\n * Create a Vector of two integer\r\n * All things vector are calculated to the origin.\r\n */\r\nclass Vector2i {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  getMagnitude() {\r\n    return Math.sqrt(this.x * this.x + this.y * this.y);\r\n  }\r\n\r\n  getMagnitudeSquare() {\r\n    return this.x * this.x + this.y * this.y;\r\n  }\r\n\r\n  /**Turn a non-zero vector into a vector of unit length*/\r\n  normalize() {\r\n    let length = this.getMagnitude();\r\n\r\n    if (length > 0) {\r\n      this.x = this.x / length;\r\n      this.y = this.y / length;\r\n    }\r\n  }\r\n\r\n  getSlope() {\r\n    return this.y / this.x;\r\n  }\r\n\r\n  getDirection(inDegrees) {\r\n    if (inDegrees) {\r\n      return (Math.atan(this.y / this.x) * 180) / Math.PI;\r\n    }\r\n    return Math.atan(this.y / this.x);\r\n  }\r\n\r\n  invert() {\r\n    this.x = -this.x;\r\n    this.y = -this.y;\r\n  }\r\n\r\n  /**\r\n   * Multiply a scalar value with this vector.\r\n   * The parameter to pass is a scalar value not a vector.\r\n   *  */\r\n  multiplyScalar(value) {\r\n    this.x *= value;\r\n    this.y *= value;\r\n  }\r\n\r\n  getMultiplicationScalarVector(value) {\r\n    return new Vector2i(this.x * value, this.y * value);\r\n  }\r\n\r\n  /**Add another vector to this vector */\r\n  addVector(vector) {\r\n    this.x += vector.x;\r\n    this.y += vector.y;\r\n  }\r\n\r\n  getAdditionVector(vector) {\r\n    return new Vector2i(this.x + vector.x, this.y + vector.y);\r\n  }\r\n\r\n  /**Subtract given vector from this vector */\r\n  subtractVector(vector) {\r\n    this.x -= vector.x;\r\n    this.y -= vector.y;\r\n  }\r\n\r\n  getSubtractionVector(vector) {\r\n    return new Vector2i(this.x - vector.x, this.y - vector.y);\r\n  }\r\n\r\n  /**Add scaled vector to this vector */\r\n  addScaledVector(vector, scale) {\r\n    this.x += vector.x * scale;\r\n    this.y += vector.y * scale;\r\n  }\r\n\r\n  /**Component Product : Similar to adding and subtracting. Has no direct geometric significance. */\r\n  componentProduct(vector) {\r\n    this.x *= vector.x;\r\n    this.y *= vector.y;\r\n  }\r\n\r\n  getComponentProductVector(vector) {\r\n    return new Vector2i(this.x * vector.x, this.y * vector.y);\r\n  }\r\n\r\n  /**Scalar Product of given vector with this vector. */\r\n  getScalarProduct(vector) {                    \r\n    return this.x*vector.x + this.y*vector.y;\r\n  }\r\n  //The scalar value returned => \r\n  //a.b = |a||b|cos(theta) =>\r\n  //theta represents the angle between the two given vectors\r\n   \r\n}\r\n\r\n/**\r\n * Add Velocity Vector and LastPosition Vector to the objects that can be moved.\r\n * @param {Rectanle || Point} object \r\n */\r\nfunction setMovable(object){\r\n  object.isMovable = true;\r\n  object.velocity = new Vector2i(0, 0);\r\n  object.lastPosition = new Vector2i(object.vec.x, object.vec.y);\r\n}\r\n\r\nfunction updateLastPostion(object){\r\n  if(object.isMovable){\r\n    object.lastPosition.x = object.vec.x;\r\n    object.lastPosition.y = object.vec.y;\r\n  }\r\n}\r\n\r\n//--- Points\r\n\r\n/**\r\n * Create A point of two integer positions x and y.\r\n * Has a draw function\r\n */\r\nclass Point {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  draw(context, color, size) {\r\n    context.fillStyle = color;\r\n\r\n    if (size > 1) {\r\n      context.beginPath();\r\n      context.arc(this.x, this.y, size, 0, 2 * Math.PI);\r\n      context.fill();\r\n    } else {\r\n      context.fillRect(this.x, this.y, 1, 1);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Join points in an array, sequenced according to index of the points.\r\n * @param {context} context\r\n * @param {Array} points\r\n * @param {string} color\r\n * @param {Number} thickness\r\n */\r\nPoint.joinPointArray = function (context, points, color, thickness) {\r\n  if (typeof color === \"string\") {\r\n    context.strokeStyle = color;\r\n  }\r\n\r\n  if (typeof thickness === \"number\" && thickness > 1) {\r\n    context.lineWidth = thickness;\r\n  }\r\n\r\n  if (Array.isArray(points)) {\r\n    context.beginPath();\r\n    context.moveTo(points[0].x, points[0].y);\r\n\r\n    for (let i = 1; i < points.length; i++) {\r\n      context.lineTo(points[i].x, points[i].y);\r\n    }\r\n\r\n    context.stroke();\r\n  }\r\n};\r\n\r\n//--- Lines\r\nclass Line {\r\n  constructor(point1, point2) {\r\n    this.point1 = point1;\r\n    this.point2 = point2;\r\n  }\r\n\r\n  draw(context, color, thickness) {\r\n    if (typeof color === \"string\") {\r\n      context.strokeStyle = color;\r\n    }\r\n\r\n    if (typeof thickness === \"number\") {\r\n      context.lineWidth = thickness;\r\n    }\r\n\r\n    context.beginPath();\r\n    context.moveTo(this.point1.x, this.point1.y);\r\n    context.lineTo(this.point2.x, this.point2.y);\r\n    context.stroke();\r\n  }\r\n\r\n  getSlope() {\r\n    return (this.point1.y - this.point2.y) / (this.point1.x - this.point2.x);\r\n  }\r\n\r\n  getLength() {\r\n    return Math.sqrt(\r\n      Math.pow(this.point1.x - this.point2.x, 2) +\r\n        Math.pow(this.point1.y - this.point2.y, 2)\r\n    );\r\n  }\r\n\r\n  getAngleWithXAxis(inDegrees) {\r\n    if (inDegrees) {\r\n      return (Math.atan(this.getSlope()) * 180) / Math.PI;\r\n    } else {\r\n      return Math.atan(this.getSlope());\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get the point of intersection between two lines.\r\n * @param {Line} line1 \r\n * @param {Line} line2 \r\n */\r\nLine.getIntersectionPoint = function (line1, line2) {\r\n  const x1 = line1.point1.x;\r\n  const y1 = line1.point1.y;\r\n  const x2 = line1.point2.x;\r\n  const y2 = line1.point2.y;\r\n  const x3 = line2.point1.x;\r\n  const y3 = line2.point1.y;\r\n  const x4 = line2.point2.x;\r\n  const y4 = line2.point2.y;\r\n\r\n  //Line line intersection on wiki : https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\r\n  let denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n\r\n  let intersectionPoint = new Point(0, 0);\r\n\r\n  //Cant divide by zero, denominator can be negative value;\r\n  if (denominator !== 0) {\r\n    intersectionPoint.x =\r\n      ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) /\r\n      denominator;\r\n    intersectionPoint.y =\r\n      ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) /\r\n      denominator;\r\n    return intersectionPoint;\r\n  } else return false;\r\n};\r\n\r\n/**\r\n * Get the angle between two given lines.\r\n * @param {Line} line1 \r\n * @param {Line} line2 \r\n * @param {boolean} inDegrees \r\n */\r\nLine.getAngleBetweenLines = function (line1, line2, inDegrees) {\r\n  let m1 = line1.getSlope();\r\n  let m2 = line2.getSlope();\r\n\r\n  if (inDegrees) {\r\n    return (Math.atan((m1 - m2) / (1 + m1 * m2)) * 180) / Math.PI;\r\n  }\r\n  return Math.atan((m1 - m2) / (1 + m1 * m2));\r\n};\r\n\r\n//--- Rectangle\r\nclass Rectangle {\r\n  constructor(vec1, vec2) {\r\n    this.vec = vec1;\r\n    this.width = vec2.x;\r\n    this.height = vec2.y;\r\n    this.vec_center = new Vector2i(\r\n      (vec1.x + vec2.x + vec1.x) / 2,\r\n      (vec1.y + vec2.y + vec1.y) / 2\r\n    );\r\n    this.color = \"black\";\r\n  }\r\n\r\n  draw(context, color) {\r\n    if (typeof color === \"string\") {\r\n      context.fillStyle = color;\r\n    } else {\r\n      context.fillStyle = this.color;\r\n    }\r\n\r\n    context.fillRect(this.vec.x, this.vec.y, this.width, this.height);\r\n  }\r\n\r\n  drawSprite(context, image, vec_startLocation, img_width, img_height) {\r\n    if (image) {\r\n      context.drawImage(\r\n        image,\r\n        vec_startLocation.x,\r\n        vec_startLocation.y,\r\n        img_width,\r\n        img_height, //src coords\r\n        this.vec.x,\r\n        this.vec.y,\r\n        this.width,\r\n        this.height //dst coords\r\n      );\r\n    }\r\n  }\r\n\r\n  rotateSpriteAndDraw(\r\n    context,\r\n    image,\r\n    angle,\r\n    vec_startLocation,\r\n    img_width,\r\n    img_height\r\n  ) {\r\n    if (image) {\r\n      context.save();\r\n      context.translate(\r\n        this.vec.x + this.width / 2,\r\n        this.vec.y + this.height / 2\r\n      );\r\n      context.rotate(angle); //* Math.PI / 180);\r\n      //We dont need to have the x and y  position of the image as we have already\r\n      //translated to that location and draw the image directly.\r\n      context.drawImage(\r\n        image,\r\n        vec_startLocation.x,\r\n        vec_startLocation.y,\r\n        img_width,\r\n        img_height,\r\n        -this.width / 2,\r\n        -this.height / 2,\r\n        this.width,\r\n        this.height\r\n      );\r\n      context.restore();\r\n    }\r\n  }\r\n}\r\n\r\n\r\n//-- Tile Map Utility functions\r\nclass Tiles{}\r\n\r\n/**\r\n * Precalculate the origin coordinate for each tile in a tile map and store in an array.\r\n * @param {number} rows \r\n * @param {number} columns \r\n * @param {number} tileSize \r\n */\r\nTiles.generateTileArray = function (rows, columns, tileSize){\r\n  let tileArray = [];\r\n\r\n  for(let row = 0; rows > row; row++){\r\n    for(let col = 0; columns > col; col++){\r\n      tileArray.push(new Vector2i(col*tileSize, row*tileSize));\r\n    }\r\n  }\r\n\r\n  return tileArray;\r\n}\r\n\r\n/**\r\n * This gives the cell number calcuated going from left to right and returning to leftmost column for next row.\r\n * row and column are not origin points of the rectangle representing the tile but actual row and column number.\r\n * @param {number} row \r\n * @param {number} column \r\n * @param {number} totalColumns \r\n */\r\nTiles.getCellNumber = function (row, column, totalColumns){\r\n  return (row*column) + column - totalColumns;\r\n}\r\n\r\n/**\r\n * Gives Row Number count starting from 1\r\n * @param {number} cellNumber \r\n * @param {number} totalColumns \r\n */\r\nTiles.getRow = function (cellNumber, totalColumns){\r\n  let row =  cellNumber/totalColumns;\r\n  let deltarow = row - Math.floor(row);\r\n  if(deltarow !== 0){\r\n    row++;\r\n  }\r\n  return Math.floor(row);\r\n}\r\n\r\n/**\r\n * Gives Column Number count starting from 1\r\n * @param {number} cellNumber \r\n * @param {number} totalColumns \r\n */\r\nTiles.getColumn = function (cellNumber, totalColumns){\r\n\r\n  let colNumber = cellNumber % totalColumns;\r\n\r\n  if(colNumber === 0) {\r\n    return totalColumns;\r\n  }\r\n  else return colNumber;\r\n  \r\n}\r\n\r\n/**\r\n * Draw a single tile at from the Tile image to the screen.\r\n * @param {Canvas.context} context \r\n * @param {image} tilesImage \r\n * @param {Vector2i} imageOrigin UpperRight corner of selected tile\r\n * @param {number} tileSizeOfImage Original Tile size in image\r\n * @param {Vector2i} drawOrigin Upper Right corner the Tile to be drawn\r\n * @param {number} drawTileSize Size of tile to be drawn\r\n */\r\nTiles.drawTile = function (\r\n  context,\r\n  tilesImage,\r\n  imageOrigin,\r\n  tileSizeOfImage,\r\n  drawOrigin,\r\n  drawTileSize\r\n) {\r\n  context.drawImage(\r\n    tilesImage,\r\n    imageOrigin.x,\r\n    imageOrigin.y,\r\n    tileSizeOfImage,\r\n    tileSizeOfImage,\r\n    drawOrigin.x,\r\n    drawOrigin.y,\r\n    drawTileSize,\r\n    drawTileSize\r\n  );\r\n};\r\n\n\n//# sourceURL=webpack://webengine/./src/Canvas.js?");

/***/ }),

/***/ "./src/collision.js":
/*!**************************!*\
  !*** ./src/collision.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"aabb\": () => (/* binding */ aabb),\n/* harmony export */   \"checkAndResolveCollision\": () => (/* binding */ checkAndResolveCollision),\n/* harmony export */   \"parseCollisionRectangles\": () => (/* binding */ parseCollisionRectangles)\n/* harmony export */ });\n/* harmony import */ var _Canvas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Canvas.js */ \"./src/Canvas.js\");\n\r\n\r\nfunction aabb(rect1, rect2) {\r\n  if (\r\n    rect1.vec.x < rect2.vec.x + rect2.width &&\r\n    rect1.vec.x + rect1.width > rect2.vec.x &&\r\n    rect1.vec.y < rect2.vec.y + rect2.height &&\r\n    rect1.vec.y + rect1.height > rect2.vec.y\r\n  ) {\r\n    // collision detected!\r\n\r\n    let collisionSide = true;\r\n\r\n    if (rect1.vec.x < rect2.vec.x + rect2.width) {\r\n      collisionSide = 2;\r\n    }\r\n\r\n    if (rect1.vec.x + rect1.width > rect2.vec.x) {\r\n      collisionSide = 1;\r\n    }\r\n\r\n    return collisionSide;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Check collision of rect1 with rect2. Important : rect1 will be resolved, rect2 remains uneffected.\r\n * @param {Rectangle} rect1\r\n * @param {Rectangle} rect2\r\n */\r\nfunction checkAndResolveCollision(rect1, rect2, rect1IsMovable, rect2IsMovable) {\r\n  if (!aabb(rect1, rect2)) return;\r\n\r\n  if (rect2IsMovable) {\r\n    //rect1 collides with the top of rect2\r\n\r\n    console.log(\"Movable second rect detected\");\r\n\r\n    if (\r\n      rect1.vec.y + rect1.height >= rect2.vec.y &&\r\n      rect1.lastPosition.y + rect1.height <= rect2.lastPosition.y\r\n    ) {\r\n      rect1.vec.y = rect2.vec.y - rect1.height - 1;\r\n    }\r\n    //rect1 collides with the bottom of rect2\r\n    else if (\r\n      rect1.vec.y <= rect2.vec.y + rect2.height &&\r\n      rect1.lastPosition.y >= rect2.lastPosition.y + rect2.height\r\n    ) {\r\n      rect1.vec.y = rect2.vec.y + rect2.height + 1;\r\n    }\r\n    //rect1 collides with the left of rect2\r\n    else if (\r\n      rect1.vec.x + rect1.width >= rect2.vec.x &&\r\n      rect1.lastPosition.x + rect1.width <= rect2.lastPosition.x\r\n    ) {\r\n      rect1.vec.x = rect2.vec.x - rect1.width - 1;\r\n    }\r\n    //rect1 collides witht the right of rect2\r\n    else if (\r\n      rect1.vec.x < rect2.vec.x + rect2.width &&\r\n      rect1.lastPosition.x >= rect2.lastPosition.x + rect2.width\r\n    ) {\r\n      rect1.vec.x = rect2.vec.x + rect2.width + 1;\r\n    }\r\n  }\r\n\r\n  //when rect2 is static and does not have a veclocity of its own\r\n  else {\r\n    //rect1 collides with the top of rect2\r\n    if (\r\n      rect1.vec.y + rect1.height >= rect2.vec.y &&\r\n      rect1.lastPosition.y + rect1.height <= rect2.vec.y\r\n    ) {\r\n      rect1.vec.y = rect2.vec.y - rect1.height - 1;\r\n    }\r\n    //rect1 collides with the bottom of rect2\r\n    else if (\r\n      rect1.vec.y <= rect2.vec.y + rect2.height &&\r\n      rect1.lastPosition.y >= rect2.vec.y + rect2.height\r\n    ) {\r\n      rect1.vec.y = rect2.vec.y + rect2.height + 1;\r\n    }\r\n    //rect1 collides with the left of rect2\r\n    else if (\r\n      rect1.vec.x + rect1.width >= rect2.vec.x &&\r\n      rect1.lastPosition.x + rect1.width <= rect2.vec.x\r\n    ) {\r\n      rect1.vec.x = rect2.vec.x - rect1.width - 1;\r\n    }\r\n    //rect1 collides witht the right of rect2\r\n    else if (\r\n      rect1.vec.x < rect2.vec.x + rect2.width &&\r\n      rect1.lastPosition.x >= rect2.vec.x + rect2.width\r\n    ) {\r\n      rect1.vec.x = rect2.vec.x + rect2.width + 1;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Generates array of rectangles that would be used to check collision from the array that has cells represented\r\n * by a number.\r\n * This will reduce the number of collision cells that need to be checked individually and from larger rectanges\r\n * combining these cells.\r\n *\r\n * @param {array} collisionTilesArray Collision Tile\r\n * @param {number} MAPTILESIZE Size each tile is to be drawn\r\n * @param {number} COLCOLU Max tile in each column\r\n * @param {number} COLROW max number of rows\r\n * @param {number} TILENUMBER number representing collision cell in the array\r\n */\r\nlet parseCollisionRectangles = function (\r\n  collisionTilesArray,\r\n  MAPTILESIZE,\r\n  COLCOLU,\r\n  COLROW,\r\n  TILENUMBER\r\n) {\r\n  let colArr = [...collisionTilesArray];\r\n  let colRectArr = [];\r\n\r\n  for (let i = 0; i < colArr.length; i++) {\r\n    if (colArr[i] === TILENUMBER) {\r\n      let cellNumber = i + 1;\r\n      let x = (_Canvas_js__WEBPACK_IMPORTED_MODULE_0__.Tiles.getColumn(cellNumber, COLCOLU) - 1) * MAPTILESIZE;\r\n      let y = (_Canvas_js__WEBPACK_IMPORTED_MODULE_0__.Tiles.getRow(cellNumber, COLCOLU) - 1) * MAPTILESIZE;\r\n      let rect = new _Canvas_js__WEBPACK_IMPORTED_MODULE_0__.Rectangle(\r\n        new _Canvas_js__WEBPACK_IMPORTED_MODULE_0__.Vector2i(x, y),\r\n        new _Canvas_js__WEBPACK_IMPORTED_MODULE_0__.Vector2i(MAPTILESIZE, MAPTILESIZE)\r\n      );\r\n      colArr[i] = 0;\r\n\r\n      //Get max width for this rectangle\r\n      let count = 0;\r\n      let maxCount = COLCOLU - _Canvas_js__WEBPACK_IMPORTED_MODULE_0__.Tiles.getColumn(cellNumber + 1, COLCOLU);\r\n      while (count <= maxCount) {\r\n        let currentCellNumber = cellNumber + 1 + count;\r\n        if (colArr[currentCellNumber - 1] === TILENUMBER) {\r\n          count++;\r\n          colArr[currentCellNumber - 1] = 0;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n      rect.width = (count + 1) * MAPTILESIZE;\r\n\r\n      //Get max height for this rectangle\r\n      let rowCount = 1;\r\n      //As we have already checked for the row of current cell we check for the next row from here on.\r\n      let maxRowCount =\r\n        COLROW - _Canvas_js__WEBPACK_IMPORTED_MODULE_0__.Tiles.getRow(cellNumber + COLCOLU, COLCOLU) + 1;\r\n      //countRowTill represents all the cells below our first fromed rectangle to see if there is another row that can be added\r\n      //to our existing rectangle\r\n      let maxColumnNumberCount = 1 + count;\r\n      while (rowCount <= maxRowCount) {\r\n        let currentRowStartCellNumber = cellNumber + COLCOLU * rowCount;\r\n        let colCount = 0;\r\n        while (colCount < maxColumnNumberCount) {\r\n          if (colArr[currentRowStartCellNumber - 1 + colCount] === TILENUMBER) {\r\n            colCount++;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n        if (colCount === maxColumnNumberCount) {\r\n          replaceArrFromTo(\r\n            colArr,\r\n            0,\r\n            currentRowStartCellNumber - 1,\r\n            maxColumnNumberCount + currentRowStartCellNumber - 1\r\n          );\r\n          rowCount++;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n\r\n      rect.height = rowCount * MAPTILESIZE;\r\n\r\n      colRectArr.push(rect);\r\n    }\r\n  }\r\n  return colRectArr;\r\n};\r\n\r\nlet replaceArrFromTo = function (arr, changeTo, startIndex, endIndex) {\r\n  for (let i = startIndex; i < endIndex; i++) {\r\n    arr[i] = changeTo;\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack://webengine/./src/collision.js?");

/***/ }),

/***/ "./src/input.js":
/*!**********************!*\
  !*** ./src/input.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KeyPressed\": () => (/* binding */ KeyPressed),\n/* harmony export */   \"add_events\": () => (/* binding */ add_events),\n/* harmony export */   \"getMousePostion\": () => (/* binding */ getMousePostion),\n/* harmony export */   \"isRightClicked\": () => (/* binding */ isRightClicked),\n/* harmony export */   \"isLeftClicked\": () => (/* binding */ isLeftClicked)\n/* harmony export */ });\nlet mouse_position = {\r\n    x : 0,\r\n    y : 0\r\n};\r\n\r\nlet right_down = false;\r\nlet left_down = false;\r\n\r\nlet KeyPressed = {\r\n  A : false,\r\n  S : false,\r\n  D : false,\r\n  W : false,\r\n  space : false,\r\n  shift : false,\r\n  Q : false,\r\n  E : false,\r\n  F : false,\r\n  clrt : false,\r\n  alt : false\r\n}\r\n\r\nfunction add_events(element) {\r\n\r\n  element.addEventListener('contextmenu', event => event.preventDefault());\r\n\r\n  element.addEventListener(\"mousemove\", (event) => {\r\n    mouse_position.x = event.clientX;\r\n    mouse_position.y = event.clientY;\r\n  });\r\n\r\n  element.addEventListener('mousedown', (event)=>{\r\n    if(event.button === 0){\r\n      right_down = true;\r\n    }else if(event.button === 2){\r\n      left_down = true;\r\n    }\r\n  });\r\n\r\n  element.addEventListener('mouseup', (event)=>{\r\n    if(event.button === 0){\r\n      right_down = false;\r\n    }else if(event.button === 2){\r\n      left_down = false;\r\n    }\r\n  });\r\n\r\n  //Keyboard Buttons and their corresponding represntation in number\r\n  //S 83 D 68 space 32 W 87 shift 16 q 81 E 69 F 70 clrt 17 Alt 18\r\n\r\n  element.addEventListener('keydown', (event)=>{\r\n    //console.log(event);\r\n    if(event.keyCode === 65){\r\n      KeyPressed.A = true;\r\n    }\r\n    if(event.keyCode === 83){\r\n      KeyPressed.S = true;\r\n    }\r\n    if(event.keyCode === 68){\r\n      KeyPressed.D = true;\r\n    }\r\n    if(event.keyCode === 32){\r\n      KeyPressed.space = true;\r\n    }\r\n    if(event.keyCode === 87){\r\n      KeyPressed.W = true;\r\n    }\r\n    if(event.keyCode === 16){\r\n      KeyPressed.shift = true;\r\n    }\r\n    if(event.keyCode === 81){\r\n      KeyPressed.Q = true;\r\n    }\r\n    if(event.keyCode === 69){\r\n      KeyPressed.E = true;\r\n    }\r\n    if(event.keyCode === 70){\r\n      KeyPressed.F = true;\r\n    }\r\n    if(event.keyCode === 17){\r\n      KeyPressed.clrt = true;\r\n    }\r\n    if(event.keyCode === 18){\r\n      KeyPressed.alt = true;\r\n    }\r\n  })\r\n\r\n  element.addEventListener('keyup', (event)=>{\r\n    if(event.keyCode === 65){\r\n      KeyPressed.A = false;\r\n    }\r\n    if(event.keyCode === 83){\r\n      KeyPressed.S = false;\r\n    }\r\n    if(event.keyCode === 68){\r\n      KeyPressed.D = false;\r\n    }\r\n    if(event.keyCode === 32){\r\n      KeyPressed.space = false;\r\n    }\r\n    if(event.keyCode === 87){\r\n      KeyPressed.W = false;\r\n    }\r\n    if(event.keyCode === 16){\r\n      KeyPressed.shift = false;\r\n    }\r\n    if(event.keyCode === 81){\r\n      KeyPressed.Q = false;\r\n    }\r\n    if(event.keyCode === 69){\r\n      KeyPressed.E = false;\r\n    }\r\n    if(event.keyCode === 70){\r\n      KeyPressed.F = false;\r\n    }\r\n    if(event.keyCode === 17){\r\n      KeyPressed.clrt = false;\r\n    }\r\n    if(event.keyCode === 18){\r\n      KeyPressed.alt = false;\r\n    }\r\n  })\r\n}\r\n\r\nfunction getMousePostion(){\r\n    return mouse_position;\r\n}\r\n\r\nfunction isRightClicked(){\r\n  return right_down;\r\n}\r\n\r\nfunction isLeftClicked(){\r\n  return left_down;\r\n}\n\n//# sourceURL=webpack://webengine/./src/input.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./index.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;